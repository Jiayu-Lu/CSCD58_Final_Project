<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>CSCD58_Final_Project.packet_capture.packet_capture API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>CSCD58_Final_Project.packet_capture.packet_capture</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import scapy.all as scapy
import threading
import time

from queue import Queue
from collections import deque

from objects.trimmed_packet import TrimmedPacket
from objects.tcp_connection import TCPConnection
from settings import (
    IF_NAME,
    ATTACK_SERVER_IP,
    CONNECTION_WINDOW,
    SERVER_IP,
)
from utils.static_definitions import CONNECTION_DATA_NAMES, FLAG_MAP
from utils.algorithms import Algorithms

from attack_detection.ids import IDS

class PacketCapture:
    &#34;&#34;&#34; Packet sniffer object, used to sniff packets on the network.

    The packet capture starts the sniffer on another thread, and analyzes data coming from it.
    It the packages the data and sends it to the IDS for classification.

    Attributes:
        timeout (float): timeout in seconds for the packet capture, default INT32_MAX
        detect_interval (float): time interval to run the IDS, in milliseconds
        packet_process_queue (Queue): thread-safe queue to communicate with packet sniffer
        connection_window (deque): double-ended queue to hold connection information within the last 2 seconds
        ids (IDS): the ids object to be used
        oldest_connection (float): the oldest connection time value in the connection window.
    &#34;&#34;&#34;
    def __init__(
        self,
        algo: Algorithms,
        timeout: float = (2**32 - 1),
        detect_interval: int = 1000,
    ):
        self.timeout: float = timeout
        # The time interval that we pop captured from queue, process each packet and run ML model (in milliseconds)
        self.detect_interval: float = detect_interval / 1000

        # temporarily store packet for processing
        self.packet_process_queue: Queue[scapy.packet.Packet] = Queue()
        # current established tcp connection
        self.current_connection: TCPConnection = None
        # previously established connection
        self.connection_window: deque[TCPConnection] = deque()

        self.ids = IDS(algo)

        self.oldest_connection: float = -1

    # Method to start packet capture and packet analysis threads
    def run(self):
        print(&#34;Started Intrusion Detection System&#34;)
        print(
            &#34;In another terminal use the start-attack command to start an attack to this server&#34;
        )
        packet_sniff = threading.Thread(target=self.start_sniff)

        packet_sniff.start()
        self.analyze_packet()

    def detect_intrusion(self):
        if self.current_connection is not None:
            print(&#34;Received a new packet.&#34;)
            print(&#34;Predicting Intrusion:&#34;)
            print(self.ids.classify_connection(self.current_connection))

    def analyze_packet(self):
        prev: float = time.time()
        start: float = time.time()

        # This is where we extract packet data
        while time.time() - start &lt; self.timeout:
            packet = self.packet_process_queue.get()
            self.process_packet(packet)
            t = time.time()
            if t - prev &gt; self.detect_interval:
                prev = t
                self.detect_intrusion()

    def process_packet(self, packet: scapy.packet.Packet):
        trimmed_packet = TrimmedPacket(packet)

        if &#34;S&#34; in trimmed_packet.flags:
            if self.current_connection is not None:
                self.close_current_connection()
            self.current_connection = self.create_tcp_connection(trimmed_packet)
        elif &#34;F&#34; in trimmed_packet.flags:
            if self.current_connection is not None:
                self.current_connection.fin = True
                self.close_current_connection()
        elif self.current_connection is not None:
            self.current_connection.add_packet(trimmed_packet)

    def start_sniff(self):
        scapy.sniff(iface=IF_NAME, prn=self.queue_packet, store=0)

    def queue_packet(self, packet: scapy.packet.Packet):
        if scapy.TCP not in packet:
            return
        if scapy.IP not in packet:
            return
        if packet[scapy.IP].src != ATTACK_SERVER_IP:
            return
        if packet[scapy.IP].dst != SERVER_IP:
            return

        self.packet_process_queue.put(packet)

    def close_current_connection(self):
        self.current_connection.close_connection()
        self.connection_window.append(self.current_connection)

        if self.oldest_connection == -1.0:
            self.oldest_connection = self.current_connection.end_time
        else:
            while time.time() - self.oldest_connection &gt; CONNECTION_WINDOW:
                self.connection_window.popleft()
                if not self.connection_window:
                    self.oldest_connection == -1.0
                    break
                self.oldest_connection = self.connection_window[0].end_time

        self.current_connection = None

    def create_tcp_connection(self, trimmed_packet: TrimmedPacket) -&gt; TCPConnection:
        data = self.calc_stats(trimmed_packet)
        count_same = 1 if data[&#34;count_same&#34;] == 0 else data[&#34;count_same&#34;]
        dst_host_count = 1 if data[&#34;dst_host_count&#34;] == 0 else data[&#34;dst_host_count&#34;]

        return TCPConnection(
            trimmed_packet.protocol,
            trimmed_packet.src_ip,
            trimmed_packet.src_port,
            trimmed_packet.dst_ip,
            trimmed_packet.dst_port,
            trimmed_packet.service,
            trimmed_packet.src_ip == trimmed_packet.dst_ip
            and trimmed_packet.src_port == trimmed_packet.dst_port,
            count_same,
            data[&#34;serror_count&#34;] / count_same,
            data[&#34;rerror_count&#34;] / count_same,
            data[&#34;same_srv_count&#34;] / count_same,
            data[&#34;diff_srv_count&#34;] / count_same,
            dst_host_count,
            data[&#34;dst_host_srv_count&#34;],
            data[&#34;dst_host_diff_srv_count&#34;] / dst_host_count,
            data[&#34;dst_host_same_src_port_count&#34;] / dst_host_count,
            data[&#34;dst_host_diff_src_port_count&#34;] / dst_host_count,
            data[&#34;same_srv_count&#34;],
        )

    def calc_stats(self, syn_packet: TrimmedPacket):
        data = dict.fromkeys(CONNECTION_DATA_NAMES, 0)

        for connection in self.connection_window:
            if connection.source_ip == syn_packet.src_ip:
                data[&#34;count_same&#34;] += 1
                if connection.flag == FLAG_MAP[&#34;S0&#34;]:
                    data[&#34;serror_count&#34;] += 1
                if connection.flag == FLAG_MAP[&#34;REJ&#34;]:
                    data[&#34;rerror_count&#34;] += 1
                if syn_packet.service == connection.service:
                    data[&#34;same_srv_count&#34;] += 1
                else:
                    data[&#34;diff_srv_count&#34;] += 1
            if syn_packet.dst_ip == connection.dest_ip:
                data[&#34;dst_host_count&#34;] += 1
                if syn_packet.service == connection.service:
                    data[&#34;dst_host_srv_count&#34;] += 1
                else:
                    data[&#34;dst_host_diff_srv_count&#34;] += 1
                if syn_packet.dst_port == connection.dest_port:
                    data[&#34;dst_host_same_src_port_count&#34;] += 1
                else:
                    data[&#34;dst_host_diff_src_port_count&#34;] += 1

        return data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture"><code class="flex name class">
<span>class <span class="ident">PacketCapture</span></span>
<span>(</span><span>algo: utils.algorithms.Algorithms, timeout: float = 4294967295, detect_interval: int = 1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Packet sniffer object, used to sniff packets on the network.</p>
<p>The packet capture starts the sniffer on another thread, and analyzes data coming from it.
It the packages the data and sends it to the IDS for classification.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>timeout in seconds for the packet capture, default INT32_MAX</dd>
<dt><strong><code>detect_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>time interval to run the IDS, in milliseconds</dd>
<dt><strong><code>packet_process_queue</code></strong> :&ensp;<code>Queue</code></dt>
<dd>thread-safe queue to communicate with packet sniffer</dd>
<dt><strong><code>connection_window</code></strong> :&ensp;<code>deque</code></dt>
<dd>double-ended queue to hold connection information within the last 2 seconds</dd>
<dt><strong><code>ids</code></strong> :&ensp;<code>IDS</code></dt>
<dd>the ids object to be used</dd>
<dt><strong><code>oldest_connection</code></strong> :&ensp;<code>float</code></dt>
<dd>the oldest connection time value in the connection window.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PacketCapture:
    &#34;&#34;&#34; Packet sniffer object, used to sniff packets on the network.

    The packet capture starts the sniffer on another thread, and analyzes data coming from it.
    It the packages the data and sends it to the IDS for classification.

    Attributes:
        timeout (float): timeout in seconds for the packet capture, default INT32_MAX
        detect_interval (float): time interval to run the IDS, in milliseconds
        packet_process_queue (Queue): thread-safe queue to communicate with packet sniffer
        connection_window (deque): double-ended queue to hold connection information within the last 2 seconds
        ids (IDS): the ids object to be used
        oldest_connection (float): the oldest connection time value in the connection window.
    &#34;&#34;&#34;
    def __init__(
        self,
        algo: Algorithms,
        timeout: float = (2**32 - 1),
        detect_interval: int = 1000,
    ):
        self.timeout: float = timeout
        # The time interval that we pop captured from queue, process each packet and run ML model (in milliseconds)
        self.detect_interval: float = detect_interval / 1000

        # temporarily store packet for processing
        self.packet_process_queue: Queue[scapy.packet.Packet] = Queue()
        # current established tcp connection
        self.current_connection: TCPConnection = None
        # previously established connection
        self.connection_window: deque[TCPConnection] = deque()

        self.ids = IDS(algo)

        self.oldest_connection: float = -1

    # Method to start packet capture and packet analysis threads
    def run(self):
        print(&#34;Started Intrusion Detection System&#34;)
        print(
            &#34;In another terminal use the start-attack command to start an attack to this server&#34;
        )
        packet_sniff = threading.Thread(target=self.start_sniff)

        packet_sniff.start()
        self.analyze_packet()

    def detect_intrusion(self):
        if self.current_connection is not None:
            print(&#34;Received a new packet.&#34;)
            print(&#34;Predicting Intrusion:&#34;)
            print(self.ids.classify_connection(self.current_connection))

    def analyze_packet(self):
        prev: float = time.time()
        start: float = time.time()

        # This is where we extract packet data
        while time.time() - start &lt; self.timeout:
            packet = self.packet_process_queue.get()
            self.process_packet(packet)
            t = time.time()
            if t - prev &gt; self.detect_interval:
                prev = t
                self.detect_intrusion()

    def process_packet(self, packet: scapy.packet.Packet):
        trimmed_packet = TrimmedPacket(packet)

        if &#34;S&#34; in trimmed_packet.flags:
            if self.current_connection is not None:
                self.close_current_connection()
            self.current_connection = self.create_tcp_connection(trimmed_packet)
        elif &#34;F&#34; in trimmed_packet.flags:
            if self.current_connection is not None:
                self.current_connection.fin = True
                self.close_current_connection()
        elif self.current_connection is not None:
            self.current_connection.add_packet(trimmed_packet)

    def start_sniff(self):
        scapy.sniff(iface=IF_NAME, prn=self.queue_packet, store=0)

    def queue_packet(self, packet: scapy.packet.Packet):
        if scapy.TCP not in packet:
            return
        if scapy.IP not in packet:
            return
        if packet[scapy.IP].src != ATTACK_SERVER_IP:
            return
        if packet[scapy.IP].dst != SERVER_IP:
            return

        self.packet_process_queue.put(packet)

    def close_current_connection(self):
        self.current_connection.close_connection()
        self.connection_window.append(self.current_connection)

        if self.oldest_connection == -1.0:
            self.oldest_connection = self.current_connection.end_time
        else:
            while time.time() - self.oldest_connection &gt; CONNECTION_WINDOW:
                self.connection_window.popleft()
                if not self.connection_window:
                    self.oldest_connection == -1.0
                    break
                self.oldest_connection = self.connection_window[0].end_time

        self.current_connection = None

    def create_tcp_connection(self, trimmed_packet: TrimmedPacket) -&gt; TCPConnection:
        data = self.calc_stats(trimmed_packet)
        count_same = 1 if data[&#34;count_same&#34;] == 0 else data[&#34;count_same&#34;]
        dst_host_count = 1 if data[&#34;dst_host_count&#34;] == 0 else data[&#34;dst_host_count&#34;]

        return TCPConnection(
            trimmed_packet.protocol,
            trimmed_packet.src_ip,
            trimmed_packet.src_port,
            trimmed_packet.dst_ip,
            trimmed_packet.dst_port,
            trimmed_packet.service,
            trimmed_packet.src_ip == trimmed_packet.dst_ip
            and trimmed_packet.src_port == trimmed_packet.dst_port,
            count_same,
            data[&#34;serror_count&#34;] / count_same,
            data[&#34;rerror_count&#34;] / count_same,
            data[&#34;same_srv_count&#34;] / count_same,
            data[&#34;diff_srv_count&#34;] / count_same,
            dst_host_count,
            data[&#34;dst_host_srv_count&#34;],
            data[&#34;dst_host_diff_srv_count&#34;] / dst_host_count,
            data[&#34;dst_host_same_src_port_count&#34;] / dst_host_count,
            data[&#34;dst_host_diff_src_port_count&#34;] / dst_host_count,
            data[&#34;same_srv_count&#34;],
        )

    def calc_stats(self, syn_packet: TrimmedPacket):
        data = dict.fromkeys(CONNECTION_DATA_NAMES, 0)

        for connection in self.connection_window:
            if connection.source_ip == syn_packet.src_ip:
                data[&#34;count_same&#34;] += 1
                if connection.flag == FLAG_MAP[&#34;S0&#34;]:
                    data[&#34;serror_count&#34;] += 1
                if connection.flag == FLAG_MAP[&#34;REJ&#34;]:
                    data[&#34;rerror_count&#34;] += 1
                if syn_packet.service == connection.service:
                    data[&#34;same_srv_count&#34;] += 1
                else:
                    data[&#34;diff_srv_count&#34;] += 1
            if syn_packet.dst_ip == connection.dest_ip:
                data[&#34;dst_host_count&#34;] += 1
                if syn_packet.service == connection.service:
                    data[&#34;dst_host_srv_count&#34;] += 1
                else:
                    data[&#34;dst_host_diff_srv_count&#34;] += 1
                if syn_packet.dst_port == connection.dest_port:
                    data[&#34;dst_host_same_src_port_count&#34;] += 1
                else:
                    data[&#34;dst_host_diff_src_port_count&#34;] += 1

        return data</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.analyze_packet"><code class="name flex">
<span>def <span class="ident">analyze_packet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_packet(self):
    prev: float = time.time()
    start: float = time.time()

    # This is where we extract packet data
    while time.time() - start &lt; self.timeout:
        packet = self.packet_process_queue.get()
        self.process_packet(packet)
        t = time.time()
        if t - prev &gt; self.detect_interval:
            prev = t
            self.detect_intrusion()</code></pre>
</details>
</dd>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.calc_stats"><code class="name flex">
<span>def <span class="ident">calc_stats</span></span>(<span>self, syn_packet: objects.trimmed_packet.TrimmedPacket)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_stats(self, syn_packet: TrimmedPacket):
    data = dict.fromkeys(CONNECTION_DATA_NAMES, 0)

    for connection in self.connection_window:
        if connection.source_ip == syn_packet.src_ip:
            data[&#34;count_same&#34;] += 1
            if connection.flag == FLAG_MAP[&#34;S0&#34;]:
                data[&#34;serror_count&#34;] += 1
            if connection.flag == FLAG_MAP[&#34;REJ&#34;]:
                data[&#34;rerror_count&#34;] += 1
            if syn_packet.service == connection.service:
                data[&#34;same_srv_count&#34;] += 1
            else:
                data[&#34;diff_srv_count&#34;] += 1
        if syn_packet.dst_ip == connection.dest_ip:
            data[&#34;dst_host_count&#34;] += 1
            if syn_packet.service == connection.service:
                data[&#34;dst_host_srv_count&#34;] += 1
            else:
                data[&#34;dst_host_diff_srv_count&#34;] += 1
            if syn_packet.dst_port == connection.dest_port:
                data[&#34;dst_host_same_src_port_count&#34;] += 1
            else:
                data[&#34;dst_host_diff_src_port_count&#34;] += 1

    return data</code></pre>
</details>
</dd>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.close_current_connection"><code class="name flex">
<span>def <span class="ident">close_current_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_current_connection(self):
    self.current_connection.close_connection()
    self.connection_window.append(self.current_connection)

    if self.oldest_connection == -1.0:
        self.oldest_connection = self.current_connection.end_time
    else:
        while time.time() - self.oldest_connection &gt; CONNECTION_WINDOW:
            self.connection_window.popleft()
            if not self.connection_window:
                self.oldest_connection == -1.0
                break
            self.oldest_connection = self.connection_window[0].end_time

    self.current_connection = None</code></pre>
</details>
</dd>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.create_tcp_connection"><code class="name flex">
<span>def <span class="ident">create_tcp_connection</span></span>(<span>self, trimmed_packet: objects.trimmed_packet.TrimmedPacket) ‑> objects.tcp_connection.TCPConnection</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tcp_connection(self, trimmed_packet: TrimmedPacket) -&gt; TCPConnection:
    data = self.calc_stats(trimmed_packet)
    count_same = 1 if data[&#34;count_same&#34;] == 0 else data[&#34;count_same&#34;]
    dst_host_count = 1 if data[&#34;dst_host_count&#34;] == 0 else data[&#34;dst_host_count&#34;]

    return TCPConnection(
        trimmed_packet.protocol,
        trimmed_packet.src_ip,
        trimmed_packet.src_port,
        trimmed_packet.dst_ip,
        trimmed_packet.dst_port,
        trimmed_packet.service,
        trimmed_packet.src_ip == trimmed_packet.dst_ip
        and trimmed_packet.src_port == trimmed_packet.dst_port,
        count_same,
        data[&#34;serror_count&#34;] / count_same,
        data[&#34;rerror_count&#34;] / count_same,
        data[&#34;same_srv_count&#34;] / count_same,
        data[&#34;diff_srv_count&#34;] / count_same,
        dst_host_count,
        data[&#34;dst_host_srv_count&#34;],
        data[&#34;dst_host_diff_srv_count&#34;] / dst_host_count,
        data[&#34;dst_host_same_src_port_count&#34;] / dst_host_count,
        data[&#34;dst_host_diff_src_port_count&#34;] / dst_host_count,
        data[&#34;same_srv_count&#34;],
    )</code></pre>
</details>
</dd>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.detect_intrusion"><code class="name flex">
<span>def <span class="ident">detect_intrusion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_intrusion(self):
    if self.current_connection is not None:
        print(&#34;Received a new packet.&#34;)
        print(&#34;Predicting Intrusion:&#34;)
        print(self.ids.classify_connection(self.current_connection))</code></pre>
</details>
</dd>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.process_packet"><code class="name flex">
<span>def <span class="ident">process_packet</span></span>(<span>self, packet: scapy.packet.Packet)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_packet(self, packet: scapy.packet.Packet):
    trimmed_packet = TrimmedPacket(packet)

    if &#34;S&#34; in trimmed_packet.flags:
        if self.current_connection is not None:
            self.close_current_connection()
        self.current_connection = self.create_tcp_connection(trimmed_packet)
    elif &#34;F&#34; in trimmed_packet.flags:
        if self.current_connection is not None:
            self.current_connection.fin = True
            self.close_current_connection()
    elif self.current_connection is not None:
        self.current_connection.add_packet(trimmed_packet)</code></pre>
</details>
</dd>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.queue_packet"><code class="name flex">
<span>def <span class="ident">queue_packet</span></span>(<span>self, packet: scapy.packet.Packet)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def queue_packet(self, packet: scapy.packet.Packet):
    if scapy.TCP not in packet:
        return
    if scapy.IP not in packet:
        return
    if packet[scapy.IP].src != ATTACK_SERVER_IP:
        return
    if packet[scapy.IP].dst != SERVER_IP:
        return

    self.packet_process_queue.put(packet)</code></pre>
</details>
</dd>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    print(&#34;Started Intrusion Detection System&#34;)
    print(
        &#34;In another terminal use the start-attack command to start an attack to this server&#34;
    )
    packet_sniff = threading.Thread(target=self.start_sniff)

    packet_sniff.start()
    self.analyze_packet()</code></pre>
</details>
</dd>
<dt id="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.start_sniff"><code class="name flex">
<span>def <span class="ident">start_sniff</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_sniff(self):
    scapy.sniff(iface=IF_NAME, prn=self.queue_packet, store=0)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="CSCD58_Final_Project.packet_capture" href="index.html">CSCD58_Final_Project.packet_capture</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture">PacketCapture</a></code></h4>
<ul class="">
<li><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.analyze_packet" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.analyze_packet">analyze_packet</a></code></li>
<li><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.calc_stats" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.calc_stats">calc_stats</a></code></li>
<li><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.close_current_connection" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.close_current_connection">close_current_connection</a></code></li>
<li><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.create_tcp_connection" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.create_tcp_connection">create_tcp_connection</a></code></li>
<li><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.detect_intrusion" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.detect_intrusion">detect_intrusion</a></code></li>
<li><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.process_packet" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.process_packet">process_packet</a></code></li>
<li><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.queue_packet" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.queue_packet">queue_packet</a></code></li>
<li><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.run" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.run">run</a></code></li>
<li><code><a title="CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.start_sniff" href="#CSCD58_Final_Project.packet_capture.packet_capture.PacketCapture.start_sniff">start_sniff</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>